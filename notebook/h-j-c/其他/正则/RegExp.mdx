---
title: RegExp


---

# 正则表达式语法

要想使用正则表达式必须首先创建一个 RegExp 对象。在 JavaScript 中有两种方式创建 RegExp 对象，一种是直接使用正则表达式文字，例如下面的代码（注意使用两个斜杠包围，并且不带引号）：

```js
var re = /ab+c/;
```

另一种是创建 RegExp 对象，该类专门用来处理正则表达式运算，下面是一个简单的构造器语法：

```js
var re = new RegExp('ab+c');
```

另外，也可以使用一个 RegExp 对象作为参数创建另一个 RegExp 对象，例如：

```js
var re = new RegExp(new RegExp('ab+c'));
```

或。

```js
var re = new RegExp(/ab+c/);
```

如果正则表达式是作为一个常量永恒不变的，那么使用文字方式是最好的选择，它可以提高运算性能；如果正则表达式后面还会有所改变，例如按照用户输入的一个正则表达式来进行匹配运算，那么就创建一个 RegExp 对象。

学习正则表达式的最便捷途径是使用范例，我们可以创建如下的范例，它将检测字符串变量 oString 中是否包含 abc 这 3 个相互紧挨的字符，这个字符使用变量 pattern 定义：

```js
// 定义正则表达式文字，你可以在这里替换正则表达式
v ar pattern = "abc"
var re = new RegExp(pattern); // 创建 RegExp 实例
var oString = "abcefg"; // 定义要匹配的字符串，可以进行替换
console.log(re.exec(oString)); // 进行匹配测试，并写出结果
```

因为变量 oString 中包含 abc ，所以匹配成功，返回了字符串 abc ；如果匹配不成功，则返回 null 。

其中变量 pattern 的值便是正则表达式，使用两个斜杠包围，其中的内容又被称为正则表达式文本或正则表达式模式（ pattern ）。

这个范例为后面学习正则表达式语法带来了方便，改变变量 pattern 的值可以重新定义正则表达式模式，改变变量 oString 的值可以重新定义要匹配的字符串。

## 优先权顺序

| 操作符                                 | 额             |
| :------------------------------------- | :------------- |
| \\                                     | 转义符         |
| \() 、 (?:) 、（？ = ）、（？！）、 [] | 圆括号和方括号 |
| \* 、 + 、 ? 、 {n} 、 {m} 、 {n,m}    | 限定符         |
| \^ 、 \$ 、 \\ 任何元字符              | 位置和顺序     |
| \|                                     | \" 或 \" 运算  |

## 创建 RegExp 对象

每一条正则表达式模式对应一个 RegExp 实例 。

- 使用 RegExp 的显式构造函数： new RegExp("pattern"[,"flags"])// 即 new RegExp(" 模式 "[," 标记 "])
- 使用 RegExp 的隐式构造函数，采用纯文本格式： /pattern/[flags]

- global ：布尔值，表示是否设置了 g 标记
- ignoreCase ：布尔值，表示是否设置了 i 标记
- unicode ：布尔值，表示是否设置了 u 标记
- sticky ：布尔值，表示是否设置了 y 标记
- lastIndex ：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始
- multiline ：布尔值，表示是否设置了 m 标记
- dotAll ：布尔值，表示是否设置了 s 标记
- source ：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的 斜杠

- flags ：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没 有前后斜杠）

pattern 为要使用的正则表达式模式文本，是必选项。在第一种方式中， pattern 部分以 JavaScript 字符串的形式存在，需要使用双引号或单引号括起来；在第二种方式中， pattern 部分嵌套在两个 " /
" 之间，不能使用引号。

flags 用于设置正则表达式的标志信息，是可选项。如果设置 flags 部分，在第一种方式中，以字符串的形式存在；在第二种方式中，以文本的形式紧接在最后一个 " / " 字符之后。 flags 可以是以下标志字符的组合。

- g 是全局标志。如果设置了这个标志，对某个文本执行搜索和替换操作时，将对文本中所有匹配的部分起作用。如果不设置这个标志，则仅搜索和替换最早匹配的内容
- i 是忽略大小写标志。如果设置了这个标志，进行匹配比较时，将忽略大小写
- m 是多行标志。
- y ：粘附模式，表示只查找从 lastIndex 开始及之后的字符串
- u ： Unicode 模式，启用 Unicode 匹配
- s ： dotAll 模式，表示元字符 . 匹配任何字符（包括 \n 或 \r ）

文本格式中的参数不要使用引号标记，而构造函数的参数则要使用引号标记 /ab+c/i new RegExp("ab+c","i")
当使用构造函数的时候，必须使用正常的字符串避开规则（在字符串中加入前导字符 \ ） re=new RegExp("\\w+") re=/\w+/
在动态创建正则表达式时，使用构造函数 RegExp() 会更便捷

由于正则表达式模式文本中的转义字符也是 " \ " ，如果正则表达式中要匹配原义字符 " \ " ，在正则表达式模式文本中要以 " \\ " 来表示。当使用显式构造函数的方式创建 RegExp 实例对象的时候，就需要使用 "
\\\\
" 来表示原义字符 " \ " 。例如： var re=new RegExp("\\\\") 。

            