---
title: http1


---

# HTTP 的基本优化

影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟

- 带宽： 现在网络基础建设已经使得带宽得到极大的提升，不再会担心由带宽而影响网速，那么就只剩下延迟了
- 延迟

- 浏览器阻塞（ HOL blocking ）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4
  个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞
- DNS 查询（ DNS Lookup ）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS 。这个通常可以利用 DNS 缓存结果来达到减少这个时间的目的

- 建立连接（ Initial connection ）： HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP
  请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大

## HTTP1.0 和 HTTP1.1

- 缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准， HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag ，
  If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略
- 带宽优化及网络连接的使用， HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能， HTTP1.1 则在请求头引入了 range
  头域，它允许只请求资源的某个部分，即返回码是 206 （ Partial Content ），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- 错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409 （ Conflict ）表示请求的资源与资源的当前状态发生冲突； 410 （ Gone ）表示服务器上的某个资源被永久性的删除

- Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（ hostname
  ）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（ Multi-homed Web Servers ），并且它们共享一个 IP 地址。 HTTP1.1 的请求消息和响应消息都应支持 Host
  头域，且请求消息中如果没有 Host 头域会报告一个错误（ 400 Bad Request ）
- 长连接， HTTP 1.1 支持长连接（ PersistentConnection ）和请求的流水线（ Pipelining ）处理，在一个 TCP 连接上可以传送多个 HTTP
  请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection ： keep-alive ，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点

它支持持续连接 . 通过这种连接 , 就有可能在建立一个 TCP 连接后 , 发送请求并得到回应 , 然后发送更多的请求并得到更多的回应 . 通过把建立和释放 TCP 连接的开销分摊到多个请求上 , 则对于每个请求而言 ,
由于 TCP 而造成的相对开销被大大地降低了 . 而且 , 还可以发送流水线请求 , 也就是说在发送请求 1 之后的回应到来之前就可以发送请求 2.
也可以认为，一次连接发送多个请求，由客户机确认是否关闭连接，而服务器会认为这些请求分别来自不同的客户端。

当连接建立起来以后 , 浏览器发送一个请求 , 之后一个回应消息被送回来 . 然后 TCP 连接被释放 . 这在早期 ,Web 页面通常只包含 HTML 文本 , 在这种情况下 , 这样的做法已经足够了 . 但是 ,
网页一般还含有大量的图标 , 图象以及其他很养眼的内容 , 所以建立一个 TCP 连接仅仅传输一个图标 , 则显得代价太昂贵了。

## HTTPS 与 HTTP 的一些区别

- HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费
- HTTP 协议运行在 TCP 之上，所有传输的内容都是明文， HTTPS 运行在 SSL/TLS 之上， SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密的
- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443
- HTTPS 可以有效的防止运营商劫持，解决了防劫持的一个大问题

## SPDY

- 对请求划分优先级
- 压缩 HTTP 头
- 服务器推送流（即 Server Push 技术）
- SPDY 试图保留 HTTP 的现有语义，所以 cookies 、 ETags 等特性都是可用的
- 多路复用请求

## 服务器推送

服务端推送能把客户端所需要的资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。

## head 压缩

假定一个页面有 100 个资源需要加载（这个数量对于今天的 Web 而言还是挺保守的） , 而每一次请求都有 1kb 的消息头（这同样也并不少见，因为 Cookie 和引用等东西的存在） ,
则至少需要多消耗 100kb 来获取这些消息头。 HTTP2.0 可以维护一个字典，差量更新 HTTP 头部，大大降低因头部传输产生的流量。

            