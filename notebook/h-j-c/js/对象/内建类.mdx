---
title: 内建类


---

# 使用 Boolean 类处理逻辑值

在 JavaScript 中内建了一个 Boolean 类，该类是一种封装类，使用 Boolean 类可获取 Boolean 对象的原始数据类型或其字符串表示形式。在 JavaScript 中， Boolean
类已成为运行时内建的类，这样，可以极大地提高性能。

要使用 Boolean 类的方法，必须首先使用构造方法 new Boolean() 创建 Boolean 类的实例。但很少有必要显式地创建 Boolean 类，所以该类并不常用。

Boolean 类有 3 个方法：

## oBoolean.toString() 方法

用来返回 Boolean 实例的字符串表示形式，结果可以是 true 或者 false 。

## oBoolean.valueOf() 方法

用来返回指定 Boolean 实例的初始值（默认值）。

Boolean 类的构造方法非常简单，语法如下：

```js
Boolean([x]);
```

参数 x 可以是任何表达式，并且是可选的。如果省略 x 参数，则将 Boolean 类初始化为 false ；如果为 x 参数指定值，则该方法会计算它，并根据 Boolean 函数中的规则以逻辑值返回结果。

例如，下面的代码创建一个名为 myBoolean 的实例并应用 valueOf() 方法：

```js
var myBoolean = new Boolean();
console.log(myBoolean.valueOf()); // 输出 false
myBoolean = true;
console.log(myBoolean.valueOf()); // 输出 true
```

## oBoolean.toJSON() 方法

该方法是 ECMAScript5 新增的方法，可以将逻辑值序列化为 JSON 格式字符串返回。其功能等同于应用 JSON.stringify() 方法，例如下面的代码效果是等同的：

```js
var myBoolean = new Boolean();
console.log(myBoolean.toJSON());
console.log(JSON.stringify(myBoolean));
```

## 使用 Number 类进行数字类型转换

在 JavaScript 程序语言中内建了 Number 类用来对数字数据进行操作，但很少有必要显式地创建这个类，所以该类并不常用。

Number 类是 Number 数据类型的一个简单的封装类，这意味着可以使用 Number 类相关的方法和属性处理原始数值。

在调用 Number 类的方法时必须使用 Number 构造器，但在调用 Number 类的属性时不需要使用此构造器，因为属性都是静态方法。

```js
var myNumber = new Number(1234);
console.log(myNumber.toString());
```

下面是一个调用 Number 类的 toString() 方法的代码：

```js
var smallest = Number.MIN_VALUE;
```

上述代码将返回数值为 1234 的字符串表达式。

下面的代码调用 Number 类的 MIN_VALUE 属性（也称为一个常数）：

Number 类的使用方法非常简单，只需要使用语法 new Number （ value ）创建实例，然后再引用实例的方法；或者调用" Number. 常量" 即可。

## Number 类的方法

Number 类包含丰富的方法，下面分别进行介绍。

## oNumber.toString([radix]) 方法

用来返回 Number 实例的字符串表示值，以不同进制表示。

参数 radix 表示要分析数字的基数（代表数字的进制），这是一个整数，合法值为 2~36 。此参数是可选的，默认值是 10 ，表示采用十进制。

例如下面的代码返回数字的十六进制表示：

```js
var myNumber = new Number(1234);
myNumber.toString(16); // 返回 4d2
```

## oNumber.toFixed(fractionDigits) 方法

用来返回 Number 实例的字符串表示值，以固定浮点表示法。

参数 fractionDigits 是介于 0 和 20 （包含 0 和 20 ）之间的整数，表示所需的小数位数。如果参数不位于该区间内，那么就会抛出 RangeError 异常。

下面的代码演示了如何返回舍入到小数点后三位的字符串（注意四舍五入）：

```js
var myNumber = new Number(3.1415926);
myNumber.toFixed(3); // 返回 3.142
```

下面的代码演示了如何返回添加尾随 0 的字符串：

```js
var myNumber = new Number(3);
myNumber.toFixed(2); // 返回 3.00
```

## oNumber.toExponential(fractionDigits) 方法

用来返回 Number 实例的字符串表示值，采用指数表示法。

参数 fractionDigits 是介于 0 和 20 （包含 0 和 20 ）之间的整数，表示所需的小数位数。如果参数不是位于这个区间，那么就会抛出 RangeError 异常。

下面的代码演示了如何返回采用指数表示法的字符串：

```js
var myNumber = new Number(3.1415926);
myNumber.toExponential(2); // 返回 3.14e+0
```

## oNumber.toPrecision(precision) 方法

用来返回 Number 实例的字符串表示值，采用不同的精确度。

参数 precision 是介于 0 和 21 （包含 0 和 21 ）之间的整数，表示所需的位数（注意，不仅仅是小数位数）。如果参数不位于该区间内，那么就会抛出 RangeError 异常。

下面的代码演示了如何返回只包含三位数的字符串，但该范例不需要使用指数表示法，因此字符串看似使用固定浮点表示法，但是并非是固定浮点表示法（对比前面的范例）：

```js
var myNumber = new Number(3.1415926);
myNumber.toPrecision(3); // 返回 3.14
```

下面的示例也演示了如何返回只包含三位数的字符串，但该范例由于结果数字中没有足够的位数来使用固定浮点表示法，因此字符串使用指数表示法：

```js
var myNumber = new Number(1234);
myNumber.toPrecision(3); // 返回 1.23e+3
```

## oNumber.valueOf() 方法

用来返回 Number 实例的初始值（也就是默认值）。例如下面的代码：

```js
var myNumber = new Number();
console.log(myNumber.valueOf()); // 输出 0 ，这表示 Number 实例的初始值为 0
```

## oNumber.toJSON() 方法

该方法是 ECMAScript 5 新增的方法，可以将数字值序列化为 JSON 格式字符串返回。其功能等同于应用 JSON.stringify() 方法，例如下面的代码效果是等同的：

```js
var myNumber = new Number(5);
console.log(myNumber.toJSON());
console.log(JSON.stringify(myNumber));
```

## Number 类的属性

Number 类的属性只需直接调用就可以使用（ Number.constant ）。

## 使用 Math 类进行复杂的数学运算

Math 类和 Number 类的功能不同，前者用来对数字进行数学运算，后者转换数字的数据类型。

要进行数学运算，可以使用前面介绍过的运算符，但是它们适于进行简单的加减乘除等运算，要进行复杂的数学运算，也可以使用这些运算符来完成，但最简便的方法是使用 JavaScript 内建的 Math 类， Math
类内建的方法和属性是封装好的复杂数学运算。使用该类的方法或属性可以访问和运算数学常数及函数。

Math 类的所有属性和方法都是静态的，只需使用语法" Math. 方法名 (argument) " 或者" Math. 常量名" 调用即可，而不需使用构造器。在 JavaScript 中，常数的最大精度为 IEEE-754
标准规定的双精度浮点数。

个别 Math 类方法使用带有角度的弧度值表示的参数。用户可以使用下面的等式计算弧度值或者简单地传递等式（输入一个度数字）给弧度参数：

```js
radian = (Math.PI / 180) * degree;
```

下面是一个把表达式作为参数以计算 45° 角的正弦值的代码：

```js
Math.sin((Math.PI / 180) * 45);
```

使用上面的语句与使用 Math.sin(0.7854) 的效果一样。

下面简单地列出 Math 类所有的方法和简要说明（这些方法都是我们中学所学过的数学运算）

## 使用 Function 和 arguments 类

JavaScript 中，用户定义的函数和内置函数都由 Function 对象来表示，该对象是 Function 类的实例。 Function 类也可以用来创建函数 。

与其紧密相关的是 arguments 对象，该对象是 Arguments 类的实例。

与 Math 类相同，可以直接调用 Function 和 arguments 对象的方法和属性，而不需使用构造器函数。

Function 类有 call() 、 apply() 和 bind() 方法。它们非常实用，都是用来调用函数的。前面介绍过，只需使用函数名后面加括号就可以调用该函数，而 Function 类的这 3 个方法提供了增强的功能。

JavaScript 中的每个函数都由一个 Function 对象来表示，所以所有的函数都支持这 3 个方法。

## oFunction.call() 方法

该方法的语法格式如下：

```js
call(thisObject [,parameter1])
```

参数 thisObject 是一个类，指定函数体内 this 关键字的值，该参数是必须的。

参数 parameterN 是可选的，是要传递给函数的参数，可以指定 0 或多个参数（参数为用逗号分隔的列表）。

几乎在所有的情形下，都可以使用函数调用运算符（也就是圆括号 () ）来代替此方法。而且函数调用运算符使得代码简明易读，但此方法主要用于需要显式地控制函数体内的 this 关键字时。

通常，如果将函数作为对象的方法来调用，则在函数体内 this 关键字表示调用该函数的对象。例如下面的代码（ this 关键字设置为 myObject ）：

```js
myObject.myMethod(1, 2, 3);
```

在某些情况下，用户可能希望函数体内的 this 关键字指向其它对象，那么就可以使用下面的方法（ this 关键字设置为 myOtherObject ）：

```js
myObject.myMethod.call(myOtherObject, 1, 2, 3);
```

也可以将空值 null 传递给参数 thisObject ，以便作为常规函数而不是作为对象的方法来调用函数。例如，下面的函数调用是等效的：

```js
Math.sin(Math.PI / 4);
Math.sin.call(null, Math.PI / 4);
```

下面的代码使用 oFunction.call() 方法使使用 oFunction.call() 方法使函数表现得像另一个对象的方法，而不将函数存储在该对象中：

```js
var myMethod = function (arg1, arg2) {
  console.log(this == obj);
};
var obj = new Object();
myMethod.call(obj, ' one ', ' another ');
```

这将会返回 true ，因为使用了 oFunction.call() 方法。

## oFunction.apply() 方法

该方法的语法格式如下：

```js
apply(thisObject [,argArray])
```

参数 thisObject 用来定义 this 关键字；而参数 argArray （可选）是一个数组，用来定义 arguments 关键字。

相比较起来， oFunction.apply() 方法要稍强于 oFunction.call() 方法，该方法有两个功用：

- 如果在 JavaScript 中调用的任何函数内使用了 this 关键字，那么可以使用 apply() 指定 this 关键字所代表的对象的值
- 如果在 JavaScript 中调用的任何函数内使用了 arguments 关键字（也可以把 arguments 当成一个类），那么可以使用 apply() 指定 arguments 关键字所代表的参数的值

可以看出，与 oFunction.call() 不同， oFunction.apply() 方法将函数的参数指定为一个 Array 对象。如果在脚本实际执行前，无法知道要传递的参数的数量，那么这种方法通常很有用。因为可以使用
arguments.length 属性确定传递给函数的参数数目（ arguments.length 属性值可以大于或小于函数声明的参数数目）。

与 oFunction.call() 方法相同，下面的函数调用是等效的：

```js
Math.atan2(1, 0);
Math.atan2.apply(null, [1, 0]);
```

下面的代码演示了如何传递参数数组给 arguments ，传递对象给 this ：

```js
var theFunction = function (arg) {
  console.log(arg);
  // 仅能获得数组参数的第一个元素
  console.log(arguments);
  // 获得 arguments 参数
  console.log(this == myObj);
  // 比较 this 关键字
}; // 创建一个对象作为 apply() 的参数
var myObj = new Object(); // 创建一个数组作为 apply() 的第二个参数
var firstArray = new Array(1, 2, 3);
theFunction.apply(null, firstArray);
/* 将会输出1 1,2,3 false
 */
// 创建另一个数组作为 apply() 的第二个参数
var secondArray = new Array(' a ', ' b ', ' c ');
theFunction.apply(myObj, secondArray); /* 将会输出 a a,b,c true */
```

此外， Function 对象还有一个属性 caller ，我们将和 arguments 属性一起介绍。

技巧与提示。

当函数没有定义参数时，也可以使用下面的方法调用该函数：

```js
theFunction.call(null);
theFunction.apply(null);
theFunction.call();
theFunction.apply();
oFunction.bind(); // 方法
```

该方法可以创建一个新函数，该函数定义了函数内的 this 关键字，并可以指定初始化参数值，其语法格式如下：

```js
bind(thisObject [,parameter1])
```

参数 thisObject 用于定义 this 关键字。

参数 parameterN 是可选的，是要传递给函数的参数，可以指定零个或多个参数（参数为用逗号分隔的列表）。

返回值是一个新函数。

例如下面的代码：

```js
var myMethod = function (arg1, arg2) {
  console.log(this == obj);
};
var obj = new Object();
var newMethod = myMethod.bind(obj, ' one ', ' another '); // 返回新函数
newMethod(); // 执行新函数 将会返回 true 下面的代码演示了使用 bind() 方法和不使用 bind() 方法的不同效果：
function showBind() {
  // 创建一个对象，该对象定义了一个方法 checkRange
  // 注意关键字 this ，它引用该对象
  var objWithProps = {
    minimum: 50,
    maximum: 100,
    checkRange: function (value) {
      if (typeof value !== ' number ') return false;
      else return value >= this.minimum && value <= this.maximum;
    },
  };
  // 调用方法 checkRange ，检测 10      是否在指定的范围内
  // 此时，注意设置的最小值是 50 ，而最大值是 100 ，所以会返回 false
  var result = objWithProps.checkRange(10);
  console.log(result);
  //    false
  // 定义一个对象包含有最小值和最大值定义，然后使用 bind() 方法
  // 那么方法 checkRange 中的 this 关键字就成了 oRange
  var oRange = { minimum: 10, maximum: 20 };
  var checkRange2 = objWithProps.checkRange.bind(oRange);
  // 此时，注意设置的最小值是 10 ，而最大值是 20 ，所以会返回 true
  var result = checkRange2(10);
  console.log(result); // true
}
```

Arguments 类和 arguments 属性

Arguments 类用于存储和访问函数的参数，它位于函数体内部，可以使用 Function 类的 arguments 属性对其进行访问。

Arguments 类代表的这些参数作为数组元素存储，第一个参数作为 arguments[0] 被访问，第二个参数作为 arguments[1] 被访问，依此类推。

arguments.length 属性表示传递给函数的参数数目。但应该再次提醒的是，传递给函数的参数与该函数声明的参数的数目可能不同。

下面是迭代参数的方法（注意，不能使用 for … in 循环遍历 arguments 对象）： 。

```js
function theFunction(arg) {
  console.log(arguments[i]);
}
```

arguments 类还有一个名为 callee 的属性，下面进行详细介绍。

## arguments.callee 属性

arguments callee 属性用来对当前正在执行的函数引用。例如下面的代码将形成一个无限循环，因为函数体内的 arguments.callee() 将会循环调用函数 theFunction() ： 。

```js
function theFunction() {
  arguments.callee(); // 调用 theFunction
}
theFunction(); // 调用 theFunction
```

## 技巧与提示

arguments.callee() 语句其实等价于 arguments.callee.apply(null) 或者 arguments.callee.call(null) 。

这个属性经常被用来创建递归函数，例如下面的定义，演示了如何利用递归函数求阶乘：

```js
function factorial(n){
if (n <= 0){
return 1;
}else{
return n \* arguments.callee(n – 1);
}
}
console.log(factorial(5));
```

(2) oFunction.caller 属性。

该属性是对当前正在执行函数的调用者（另一个函数）的引用。如果未从其它函数调用它，则为 null 。

例如下面的代码将形成一个无限循环，因为函数体内的 otherFunction.caller() 将会循环调用函数 theFunction() ：

```js
function theFunction() {
  otherFunction(); // 调用 otherFunction
}
function otherFunction() {
  console.log(otherFunction.caller()); // 调用 theFunction
}
theFunction(); // 调用 theFunction
```

技巧与提示。

otherFunction.caller() 语句其实等价于 otherFunction.caller.apply(null) 或者 otherFunction. caller.call(null) 。

            