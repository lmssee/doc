---
title: 操作对象


---

# 引用对象

在创建对象之后，可以把对象的地址赋值给变量，实现变量对对象的引用。当把变量赋值给其它的变量时，就可以实现多个变量引用同一对象。

```js
o = { x: 1, y: true };
ol = o;
alert(delete o); // 返回true ，说明删除成功
alert(ol.x); // 读取对象，显示 1
alert(o.x); // 使用 o 读取失败
```

但使用 var 声明 o 时，将不会被 delete 方法删除。

## 复制对象

就是利用 for/in 遍历对象，然后把对象每一个对象成员赋值给另一个对象。

```js
function F(x, y) {
  this.x = x;
  this.y = y;
  this.add = function () {
    return this.x + this.y;
  };
}

F.prototype.mul = function () {
  return this.x * this.y;
};
var f = new F(2, 3);
var o = {};
for (var i in f) {
  o[i] = f[i];
}
alert(o.x); // 2
alert(o.y); // 3
alert(o.add()); // 5
alert(o.mul()); // 6
```

对于上述的方法，还可以封装：

```js
Function.prototype.extend = function (o) {
  for (var i in o) {
    this.constructor.prototype[i] = o[i];
  }
};
```

复制对象实际上是通过反射机制复制对象的所有可枚举属性和方法来模拟继承。这种方法能够实现模拟多重继承。不过，它的缺点也很明显：

- 由于是反射机制，复制法不能继承非枚举类型的所有的方法，对于系统核心对象的只读属性和方法也无法继承
- 通过反射机制来复制对象成员的执行效率会非常差。当对象结构庞大时，这种低效就越明显
- 如果包含同名成员，则有可能被动态复制覆盖掉

## 克隆对象

克隆对象就是赋值，但是执行效率要高一些。

```js
Function.prototype.clone = function (o) {
  // 对象克隆方法
  function Temp() {} // 新建空构造函数
  Temp.prototype = o;
  // 把参数对象赋值给该构造函数的原型对象
  return new Temp(); // 返回实例化后的对象
};
```

调用 工具函数 clone() 。首先，为 Function 对象扩展一个方法，该方法能够把参数对象赋值给一个空的构造函数的原型对象，然后实例化构造函数，并返回实例对象，这样就把该对象拥有函数包含的所有成员。

```js
var o = Function.clone(new F(2, 3)); // 调用 Function 的克隆方法
alert(o.x); // 返回 2
alert(o.y); // 返回 3
alert(o.add()); // 返回 5
alert(o.mul()); // 返回 6
```

然后，调用这个方法克隆对象。克隆方法返回的是一个空对象，不过它储存了指向给定对象的原型对象指针。这样既可以利用原型链来访问它们，从而在不同的对象之间实现继承。

## 销毁对象

JavaScript 中有一套垃圾处理机制，能够自动回收无用的储存单元。当对象没有任何变量引用时， JavaScript 就会自动侦测，并运行垃圾回收程序把这些对象注销。以释放内存。

每当对象执行完毕，垃圾回收机制就会自动被运行，释放函数所占用的资源，并释放局部变量。另外，将函数处于一种不可预知的状态时，也会被回收处理。

```js
var o = {
  // 创建对象，并引用该对象给变量 o
  x: 1,
  y: true,
};
o = null; // 定义对象引用变量为 null ，即废除对象
alert(o.x); // 提示系统报错，找不到对象
```

在设计中，对于不用的对象，应该把其引用变量都设置为 null ，以释放内存空间。这是一种很好的设计习惯，即节约了系统开支，又可以预防错误。

            