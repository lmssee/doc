---
title: 创建


---

# 创建对象

创建对有 3 中方法。

- 构造函数
- 对象直接量
- Object.create() 方法

## 使用对象直接量创建对象

使用对象直接量来定义对象类似于函数直接量定义匿名函数。

```js
var objectName = {
  attribute: 'value',
  method: () => 1,
};
```

- 属性名和属性值之间用 冒号 分隔
- 属性值可以是任何数据类型
- 如果属性值是函数，则该属性就成为该对象的方法
- 如果属性值是对象，则会成为嵌套结构的对象
- 属性名可以是 JavaScript 标识符 , 也可以任何形式的字符串
- 属性与属性之间通过逗号分隔 , 最后一个属性末尾不必须逗号
- 使用对象直接量是创建对象的最高效、最简便的方法

使用直接量的方式创建大量相同的对象时，每次都需要写大量相同的属性和方法。产生大量的冗余代码！

## 工厂模式创建对象

工厂模式创建对象的基本思想是：把创建对象的代码封装为一个函数，并使函数返回所创建的对象。

工厂模式确实解决了创建多个相似对象时出现大量冗余代码的问题,所创建的对象全部都是 Object 对象，而不能对对象进行具体类型的识别。为解决这个问题，又出现了构造函数创建对象的方式。

## 使用构造函数创建对象

使用 new 运算符调用函数，可以构造一个实例对象。

```js
var objectName = new functionName(args);
```

简单说明如下：

- objectName 表示构造的实例对象
- functionName 表示一个构造函数，构造函数与普通函数没有本质区别。一般情况下，构造函数不需要返回值，构造函数体内使用 this 指代 objectName 实例对象
- args 表示参数列表

```js
var o = new Object(); // 创建一个空对象
var o = new Array(); // 创建一个空的数组对象
var o = new MyClass(); // 创建一个自定义的对象
```

在 JavaScript 中， Object 、 Array 、 Function 、 RegExp 、 String 等内置对象都是构造函数，使用 new 运算符可以调用它们，并初始化为一个一个对象实例。

- 使用 new 调用 , 或是小括号调用 , 但返回值不一样
- 构造函数内部通过 this 关键字指代实例化对象 , 或者指向调用对象
- 构造函数内通过点运算符声明本地成员

类名首字母大写（非强制），主要与普通函数进行区别。

构造函数没有返回值，这是它与普通函数最大的区别。它们只是初始化由 this 关键字传递进来的对象，并且什么都没有返回。但是，构造函数返回一个对象值，如果这样，被返回的对象就成了 new 表达式的值。在这种情况下， this
值所引用的对象就被丢弃了。

```js
function Box(x, y) {
  this.x = x;
  this.y = y;
  return this;
}
alert(Box(4, 5).x);
// 返回参数 4 ，此时的构造函数为普通函数
var Box1 = new Box(4, 5);
alert(Box1.x); // 调用对象的属性
```

工厂模式确实解决了创建多个相似对象时出现大量冗余代码的问题，但是它却和前面两种方式一样，所创建的对象全部都是 Object 对象，而不能对对象进行具体类型的识别。为解决这个问题，又出现了构造函数创建对象的方式。

解决的方式就是原型，通过创建原型，避免了每次实例化相同的属性和方法，占用内存。

结合构造函数和原型的方法可以创建很有用的对象：首先定义构造函数，然后在构造函数下面定义原型属性和方法，接着创建对象。

## 使用 create() 方法创建对象

ECMAScript 5 为 Object 新增一个静态方法 Object.create() ，直接调用该方法可以快速创建一个对象。 Object.create() 能够创建一个具有指定原型且可选择的包含指定属性的对象。

```js
Object.create(prototype, descriptors);
```

- prototype : 必须的参数 , 要用原型的对象 , 可以是 null
- descriptors : 可选参数 , 包含一个或多个属性描述符的 JavaScript 对象

在 descriptors 中，数据属性是可获取且设置值的属性。数据属性描述符包含 value 特性，以及 writable （是否可修改属性值）、 enumerable （是否可枚举）、 configurable （设置是否可修改属性特性和删除属性）特性。如果未指定最后三个特性，则默认为 false 。只要检索或设置该值，访问器属性就会调用用户提供的函数。访问器属性描述符包含 set （设置属性值的函数）特性和 get （返回属性值的函数）特性。

下例使用 Object.create() 创建一个对象。它继承自 null ，即把 null 作为原型。

```js
var newObj = Object.create(null, {
  size: { value: 'large', enumerable: false },
  shape: {
    value: 'round',
    enumerable: true,
  },
});
console.log(newObj.size + '');
console.log(newObj.shape + '');
console.log(Object.getPrototypeOf(newObj));
```

下例使用 Object.create() 创建一个与 Object 对象具有相同原型的对象。该对象具有跟使用对象直接量创建的对象相同的原型。 Object.getPrototypeOf 函数可获取原始对象的原型。如果要获取对象的属性描述符，可以使用 Object.getOwnPropertyDescriptor 函数。

```js
var firstLine = { x: undefined, y: undefined };
var secondLine = Object.create(Object.prototype, {
  x: {
    value: undefined,
    writable: true,
    configurable: true,
    enumerable: true,
  },
  y: {
    value: undefined,
    writable: true,
    configurable: true,
    enumerable: true,
  },
});
// first line prototype = [Object Object]
console.log('first line prototype = ' + Object.getPrototypeOf(firstLine));
console.log('\n');
// second line prototype = [Object Object]
console.log('second line prototype =' + Object.getPrototypeOf(secondLine));
```

下例创建一个对象，该对象继承自 shape 对象，即把 shape 对象作为 Square 的对象原型。

```js
var Shape = {
  twoDimensional: true,
  color: undefined,
  hasLineSegments: undefined,
};
var Square = Object.create(Shape);
console.log(Square.twoDimensional);
```

            