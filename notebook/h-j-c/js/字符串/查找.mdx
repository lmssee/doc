---
title: 查找


---

# 字符串查找

## 使用 String 类处理字符串

使用构造方法 new String （ value ）或文字字符串值，可以调用 String 类的所有成员。如果指定字符串文字， JavaScript 解释引擎会自动将其转换成临时 String
对象，然后调用其方法，最后清除临时 String 对象。用户也可以使用字符串文字的 String.length 属性。

不要混淆字符串文字和 String 实例，这是很重要的。在下面的代码中，代码的第一行创建了一个字符串文字 s1 ，代码的第二行创建了一个 String 实例 s2 ：

```js
var s1 = 'foo';
var s2 = new String('foo');
```

除非确实需要使用 String 对象（因为 String 对象可以有反常规的行为），否则建议使用字符串文字。例如下面的代码：

```js
var s1 = "; + 2"; // 设置一个字符串文字 var s2 = new String("2 + 2");
// 设置一个 String 对象 eval(s1); // 返回数字
4eval(s2); // 返回字符串 "2 + 2";
```

对于 U+0000~U+FFFF 范围内的字符， length 、 charAt() 、 charCodeAt() 和 fromCharCode() 返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用 16
位表示的，而这几个方法 也都基于 16 位码元完成操作。只要字符编码大小与码元大小一一对应，这些方法就能如期工作。

这个对应关系在扩展到 Unicode 增补字符平面时就不成立了。问题很简单，即 16 位只能唯一表示 65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面（ BMP ）。为了
表示更多的字符， Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个 字符使用两个 16 位码元的策略称为代理对。

## 方法

| 字符串方法    | 说明                           |
| :------------ | :----------------------------- |
| charAt()      | 返回字符串的第 n 个字符        |
| charCodeAt()  | 返回字符串的第 n 个字符的代码  |
| indexOf()     | 检索字符串                     |
| lastIndexOf() | 从后向前检索一个字符串         |
| match()       | 找到一个或多个正则表达式的匹配 |
| search()      | 检索与正则表达式相匹的子串     |

_扩展原型，将字符串转换为数组，将每一个字符变成数组元素_

```js
String.prototype.toArray = function () {
  var l = this.length,
    a = [];
  if (l) {
    for (var i = 0; i < l; i++) {
      a.push(this.charAt(i));
    }
  }
  return a;
};
```

charCodeAt() 和 charAt() 方法操作类似，不过它返回的是指定位置的字符编码。如果指定位置下标值为负数，或者大于等于字符串长度，则返回 NaN ，而不是 0 。

_查找字符串的位置_

charAt() 和 charCodeAt() 是按照数组下标查找字符，而 indexOf() 和 lastIndexOf() 是按照字符串查找下标。

indexOf() 有两个参数，第一个为查找的子字符串，第二个参数为查找的起始位置。取值在 0 ~ length-1 ，对于该方法。

```js
var s = 'javascript';
var i = s.indexOf('a', -10);
alert(i); // 返回 1 ，即第二个字符
```

lastIndexOf() 方法的查找顺序是从右到左，但是其参数和返回值都是根据字符串的下标从左到右的顺序来计算的。

_匹配字符串_

`search()` 方法和 `indexOf()` 方法相似，查找字符串第一次出现的位置。但它仅有一个参数，即指代的匹配模式，没有 `lastIndexOf()` 的方向匹配功能，不支持全局模式。用法不如 `lastIndexOf()` 灵活。

`search()` 方法指明是否存在相应的匹配。如果找到一个匹配，那么返回一个整数值，指明这个匹配距离字符串开始的索引位置；如果没有找到匹配，则返回 -1 。其语法格式如下：

```js
oString.search(re);
```

参数 re 既可以是包含正则表达式模式或正则表达式对象，也可以是 String 对象或文字。如果 re 不是正则表达式对象，它将被转换为字符串，并进行精确的查找。如果参数是正则表达式或正则表达式对象，该方法将忽略全局标示 `g`，并忽略此正则表达式的 `lastIndex` 属性（保持其值不变）。

例如下面的代码，将搜索字符串中的空白：

```js
var oString = 'ECMAScript version 5.0 provides many new features.';
var re = /\s/g; // 定义正则表达式模式文字，这里是匹配空白
var index = oString.search(re); // 搜索空白，返回第一个索引位置
// 写出结果
console.log(index);
```

这将会返回如下的结果： `10`

`match()` 方法能够找到所有的匹配的子字符串，并储存在数组中返回。

`match()` 方法使用正则表达式模式对字符串执行查找，并将包含查找的结果作为数组返回。其语法格式如下：

```js
oString.match(re);
```

- 参数 oString 指对其进行查找的 `String` 对象或字符串文字。
- 参数 re 是一个 `RegExp` 对象，也可以是包含正则表达式模式和可用标志的变量名或字符串文字。

如果 `match()` 方法没有找到匹配，则返回 `null` ；如果找到匹配，则返回一个数组并且更新 `RegExp` 对象的属性以反映匹配结果。

`match()` 方法返回的数组包含： input 和 index 两个属性，并可以使用数组元素访问运算符和保存的结果。

如果没有设置全局标志 `g` ， 数组的 `0` 索引元素包含整个匹配，而第 `1~n` 元素包含了匹配中曾出现过的任一个子匹配。这相当于没有设置全局标志的 `exec()` 方法。如果设置了全局标志，元素 `0~n` 中包含所有匹配。

例如下面的代码进行匹配，并将结果保存在数组中：

```js
var oString = 'ECMAScript version 5.0 provides many new features.';
var re = /\w+/g; // 定义正则表达式模式文字 var oArray =
oString.match(re); // 进行匹配测试，数组用来保存匹配的结果
// 写出结果
console.log(oArray.toString());
```

这将会返回如下的结果：
`ECMAScript,version,5,0,provides,many,new,features`

如果不使用全局标志`g` ，那么实际仅返回第一个匹配。例如下面的代码：

```js
var oString = 'ECMAScript version 5.0 provides many new features.';
var re = /\w+/; // 定义正则表达式模式文字
var oArray = oString.match(re); // 进行匹配测试，数组用来保存匹配的结果
// 写出结果
console.log(oArray.toString());
```

这将会返回如下的结果： `ECMAScript`

            